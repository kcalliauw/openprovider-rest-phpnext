<?php
/**
 * DomainServiceApi
 * PHP version 8.1
 *
 * @package  Layer7\Openprovider
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0-beta
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.11.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Layer7\Openprovider\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use Layer7\Openprovider\ApiException;
use Layer7\Openprovider\Configuration;
use Layer7\Openprovider\HeaderSelector;
use Layer7\Openprovider\ObjectSerializer;

/**
 * DomainServiceApi Class Doc Comment
 *
 * @package  Layer7\Openprovider
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DomainServiceApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'approveTransfer' => [
            'application/json',
        ],
        'checkDomain' => [
            'application/json',
        ],
        'createDomain' => [
            'application/json',
        ],
        'deleteDomain' => [
            'application/json',
        ],
        'getDomain' => [
            'application/json',
        ],
        'listDomains' => [
            'application/json',
        ],
        'renewDomain' => [
            'application/json',
        ],
        'restoreDomain' => [
            'application/json',
        ],
        'sendFoa1' => [
            'application/json',
        ],
        'tradeDomain' => [
            'application/json',
        ],
        'transferDomain' => [
            'application/json',
        ],
        'tryAgainLastOperation' => [
            'application/json',
        ],
        'updateDomain' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation approveTransfer
     *
     * Approve transfer
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainApproveTransferRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveTransfer'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainApproveTransferResponse|\Layer7\Openprovider\Model\ErrorError
     */
    public function approveTransfer(
        int $id,
        \Layer7\Openprovider\Model\DomainApproveTransferRequest $body,
        string $contentType = self::contentTypes['approveTransfer'][0]
    ): \Layer7\Openprovider\Model\DomainApproveTransferResponse
    {
        list($response) = $this->approveTransferWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation approveTransferWithHttpInfo
     *
     * Approve transfer
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainApproveTransferRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveTransfer'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainApproveTransferResponse|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function approveTransferWithHttpInfo(
        int $id,
        \Layer7\Openprovider\Model\DomainApproveTransferRequest $body,
        string $contentType = self::contentTypes['approveTransfer'][0]
    ): array
    {
        $request = $this->approveTransferRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainApproveTransferResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainApproveTransferResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainApproveTransferResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainApproveTransferResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainApproveTransferResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation approveTransferAsync
     *
     * Approve transfer
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainApproveTransferRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveTransfer'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function approveTransferAsync(
        int $id,
        \Layer7\Openprovider\Model\DomainApproveTransferRequest $body,
        string $contentType = self::contentTypes['approveTransfer'][0]
    ): PromiseInterface
    {
        return $this->approveTransferAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation approveTransferAsyncWithHttpInfo
     *
     * Approve transfer
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainApproveTransferRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveTransfer'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function approveTransferAsyncWithHttpInfo(
        $id,
        $body,
        string $contentType = self::contentTypes['approveTransfer'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainApproveTransferResponse';
        $request = $this->approveTransferRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'approveTransfer'
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainApproveTransferRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveTransfer'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function approveTransferRequest(
        $id,
        $body,
        string $contentType = self::contentTypes['approveTransfer'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling approveTransfer'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling approveTransfer'
            );
        }


        $resourcePath = '/v1beta/domains/{id}/transfer/approve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkDomain
     *
     * Check domain
     *
     * @param  \Layer7\Openprovider\Model\DomainCheckDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainCheckDomainResponse|\Layer7\Openprovider\Model\ErrorError
     */
    public function checkDomain(
        \Layer7\Openprovider\Model\DomainCheckDomainRequest $body,
        string $contentType = self::contentTypes['checkDomain'][0]
    ): \Layer7\Openprovider\Model\DomainCheckDomainResponse
    {
        list($response) = $this->checkDomainWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation checkDomainWithHttpInfo
     *
     * Check domain
     *
     * @param  \Layer7\Openprovider\Model\DomainCheckDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainCheckDomainResponse|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkDomainWithHttpInfo(
        \Layer7\Openprovider\Model\DomainCheckDomainRequest $body,
        string $contentType = self::contentTypes['checkDomain'][0]
    ): array
    {
        $request = $this->checkDomainRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainCheckDomainResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainCheckDomainResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainCheckDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainCheckDomainResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainCheckDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkDomainAsync
     *
     * Check domain
     *
     * @param  \Layer7\Openprovider\Model\DomainCheckDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function checkDomainAsync(
        \Layer7\Openprovider\Model\DomainCheckDomainRequest $body,
        string $contentType = self::contentTypes['checkDomain'][0]
    ): PromiseInterface
    {
        return $this->checkDomainAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkDomainAsyncWithHttpInfo
     *
     * Check domain
     *
     * @param  \Layer7\Openprovider\Model\DomainCheckDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function checkDomainAsyncWithHttpInfo(
        $body,
        string $contentType = self::contentTypes['checkDomain'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainCheckDomainResponse';
        $request = $this->checkDomainRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkDomain'
     *
     * @param  \Layer7\Openprovider\Model\DomainCheckDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkDomainRequest(
        $body,
        string $contentType = self::contentTypes['checkDomain'][0]
    ): Request
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling checkDomain'
            );
        }


        $resourcePath = '/v1beta/domains/check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDomain
     *
     * Create domain
     *
     * @param  \Layer7\Openprovider\Model\DomainCreateDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainCreateDomainResponse|\Layer7\Openprovider\Model\ErrorError
     */
    public function createDomain(
        \Layer7\Openprovider\Model\DomainCreateDomainRequest $body,
        string $contentType = self::contentTypes['createDomain'][0]
    ): \Layer7\Openprovider\Model\DomainCreateDomainResponse
    {
        list($response) = $this->createDomainWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation createDomainWithHttpInfo
     *
     * Create domain
     *
     * @param  \Layer7\Openprovider\Model\DomainCreateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainCreateDomainResponse|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDomainWithHttpInfo(
        \Layer7\Openprovider\Model\DomainCreateDomainRequest $body,
        string $contentType = self::contentTypes['createDomain'][0]
    ): array
    {
        $request = $this->createDomainRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainCreateDomainResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainCreateDomainResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainCreateDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainCreateDomainResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainCreateDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDomainAsync
     *
     * Create domain
     *
     * @param  \Layer7\Openprovider\Model\DomainCreateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createDomainAsync(
        \Layer7\Openprovider\Model\DomainCreateDomainRequest $body,
        string $contentType = self::contentTypes['createDomain'][0]
    ): PromiseInterface
    {
        return $this->createDomainAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDomainAsyncWithHttpInfo
     *
     * Create domain
     *
     * @param  \Layer7\Openprovider\Model\DomainCreateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createDomainAsyncWithHttpInfo(
        $body,
        string $contentType = self::contentTypes['createDomain'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainCreateDomainResponse';
        $request = $this->createDomainRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDomain'
     *
     * @param  \Layer7\Openprovider\Model\DomainCreateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDomainRequest(
        $body,
        string $contentType = self::contentTypes['createDomain'][0]
    ): Request
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createDomain'
            );
        }


        $resourcePath = '/v1beta/domains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDomain
     *
     * Delete domain
     *
     * @param  int $id Domain id number (required)
     * @param  int|null $reseller_id Reseller id. (optional)
     * @param  string|null $domain_name Domain name without extension. (optional)
     * @param  string|null $domain_extension Domain extension. (optional)
     * @param  string|null $domain_idn_extension Domain IDN extension. (optional)
     * @param  string|null $type Type of deletion request. (optional)
     * @param  int|null $skip_soft_quarantine Deletes domain, skipping the soft quarantine. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainDeleteDomainResponse|\Layer7\Openprovider\Model\ErrorError
     */
    public function deleteDomain(
        int $id,
        ?int $reseller_id = null,
        ?string $domain_name = null,
        ?string $domain_extension = null,
        ?string $domain_idn_extension = null,
        ?string $type = null,
        ?int $skip_soft_quarantine = null,
        string $contentType = self::contentTypes['deleteDomain'][0]
    ): \Layer7\Openprovider\Model\DomainDeleteDomainResponse
    {
        list($response) = $this->deleteDomainWithHttpInfo($id, $reseller_id, $domain_name, $domain_extension, $domain_idn_extension, $type, $skip_soft_quarantine, $contentType);
        return $response;
    }

    /**
     * Operation deleteDomainWithHttpInfo
     *
     * Delete domain
     *
     * @param  int $id Domain id number (required)
     * @param  int|null $reseller_id Reseller id. (optional)
     * @param  string|null $domain_name Domain name without extension. (optional)
     * @param  string|null $domain_extension Domain extension. (optional)
     * @param  string|null $domain_idn_extension Domain IDN extension. (optional)
     * @param  string|null $type Type of deletion request. (optional)
     * @param  int|null $skip_soft_quarantine Deletes domain, skipping the soft quarantine. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainDeleteDomainResponse|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDomainWithHttpInfo(
        int $id,
        ?int $reseller_id = null,
        ?string $domain_name = null,
        ?string $domain_extension = null,
        ?string $domain_idn_extension = null,
        ?string $type = null,
        ?int $skip_soft_quarantine = null,
        string $contentType = self::contentTypes['deleteDomain'][0]
    ): array
    {
        $request = $this->deleteDomainRequest($id, $reseller_id, $domain_name, $domain_extension, $domain_idn_extension, $type, $skip_soft_quarantine, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainDeleteDomainResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainDeleteDomainResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainDeleteDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainDeleteDomainResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainDeleteDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDomainAsync
     *
     * Delete domain
     *
     * @param  int $id Domain id number (required)
     * @param  int|null $reseller_id Reseller id. (optional)
     * @param  string|null $domain_name Domain name without extension. (optional)
     * @param  string|null $domain_extension Domain extension. (optional)
     * @param  string|null $domain_idn_extension Domain IDN extension. (optional)
     * @param  string|null $type Type of deletion request. (optional)
     * @param  int|null $skip_soft_quarantine Deletes domain, skipping the soft quarantine. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteDomainAsync(
        int $id,
        ?int $reseller_id = null,
        ?string $domain_name = null,
        ?string $domain_extension = null,
        ?string $domain_idn_extension = null,
        ?string $type = null,
        ?int $skip_soft_quarantine = null,
        string $contentType = self::contentTypes['deleteDomain'][0]
    ): PromiseInterface
    {
        return $this->deleteDomainAsyncWithHttpInfo($id, $reseller_id, $domain_name, $domain_extension, $domain_idn_extension, $type, $skip_soft_quarantine, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDomainAsyncWithHttpInfo
     *
     * Delete domain
     *
     * @param  int $id Domain id number (required)
     * @param  int|null $reseller_id Reseller id. (optional)
     * @param  string|null $domain_name Domain name without extension. (optional)
     * @param  string|null $domain_extension Domain extension. (optional)
     * @param  string|null $domain_idn_extension Domain IDN extension. (optional)
     * @param  string|null $type Type of deletion request. (optional)
     * @param  int|null $skip_soft_quarantine Deletes domain, skipping the soft quarantine. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteDomainAsyncWithHttpInfo(
        $id,
        $reseller_id = null,
        $domain_name = null,
        $domain_extension = null,
        $domain_idn_extension = null,
        $type = null,
        $skip_soft_quarantine = null,
        string $contentType = self::contentTypes['deleteDomain'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainDeleteDomainResponse';
        $request = $this->deleteDomainRequest($id, $reseller_id, $domain_name, $domain_extension, $domain_idn_extension, $type, $skip_soft_quarantine, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDomain'
     *
     * @param  int $id Domain id number (required)
     * @param  int|null $reseller_id Reseller id. (optional)
     * @param  string|null $domain_name Domain name without extension. (optional)
     * @param  string|null $domain_extension Domain extension. (optional)
     * @param  string|null $domain_idn_extension Domain IDN extension. (optional)
     * @param  string|null $type Type of deletion request. (optional)
     * @param  int|null $skip_soft_quarantine Deletes domain, skipping the soft quarantine. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteDomainRequest(
        $id,
        $reseller_id = null,
        $domain_name = null,
        $domain_extension = null,
        $domain_idn_extension = null,
        $type = null,
        $skip_soft_quarantine = null,
        string $contentType = self::contentTypes['deleteDomain'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling deleteDomain'
            );
        }








        $resourcePath = '/v1beta/domains/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $reseller_id,
            'reseller_id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domain_name,
            'domain.name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domain_extension,
            'domain.extension', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domain_idn_extension,
            'domain.idn_extension', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip_soft_quarantine,
            'skip_soft_quarantine', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDomain
     *
     * Get domain
     *
     * @param  int $id Domain id number (required)
     * @param  string|null $domain_name Domain name without extension. (optional)
     * @param  string|null $domain_extension Domain extension. (optional)
     * @param  string|null $domain_idn_extension Domain IDN extension. (optional)
     * @param  int|null $reseller_id Reseller id. (optional)
     * @param  string|null $queue_status The queue status. (optional)
     * @param  bool|null $with_history Returns domain mutations history. (optional)
     * @param  bool|null $with_api_history Returns domain API calls history. (optional)
     * @param  bool|null $with_additional_data Returns domain additional data. (optional)
     * @param  bool|null $with_registry_details Retrurns registry details. (optional)
     * @param  bool|null $with_dnssec_data Returns DNSSEC data. (optional)
     * @param  bool|null $with_abuse_details Returns domain abuse details. (optional)
     * @param  bool|null $with_whois_privacy_data Returns WPP data. (optional)
     * @param  bool|null $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  bool|null $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainGetDomainResponse|\Layer7\Openprovider\Model\ErrorError
     */
    public function getDomain(
        int $id,
        ?string $domain_name = null,
        ?string $domain_extension = null,
        ?string $domain_idn_extension = null,
        ?int $reseller_id = null,
        ?string $queue_status = null,
        ?bool $with_history = null,
        ?bool $with_api_history = null,
        ?bool $with_additional_data = null,
        ?bool $with_registry_details = null,
        ?bool $with_dnssec_data = null,
        ?bool $with_abuse_details = null,
        ?bool $with_whois_privacy_data = null,
        ?bool $with_registry_statuses = null,
        ?bool $is_deleted = null,
        string $contentType = self::contentTypes['getDomain'][0]
    ): \Layer7\Openprovider\Model\DomainGetDomainResponse
    {
        list($response) = $this->getDomainWithHttpInfo($id, $domain_name, $domain_extension, $domain_idn_extension, $reseller_id, $queue_status, $with_history, $with_api_history, $with_additional_data, $with_registry_details, $with_dnssec_data, $with_abuse_details, $with_whois_privacy_data, $with_registry_statuses, $is_deleted, $contentType);
        return $response;
    }

    /**
     * Operation getDomainWithHttpInfo
     *
     * Get domain
     *
     * @param  int $id Domain id number (required)
     * @param  string|null $domain_name Domain name without extension. (optional)
     * @param  string|null $domain_extension Domain extension. (optional)
     * @param  string|null $domain_idn_extension Domain IDN extension. (optional)
     * @param  int|null $reseller_id Reseller id. (optional)
     * @param  string|null $queue_status The queue status. (optional)
     * @param  bool|null $with_history Returns domain mutations history. (optional)
     * @param  bool|null $with_api_history Returns domain API calls history. (optional)
     * @param  bool|null $with_additional_data Returns domain additional data. (optional)
     * @param  bool|null $with_registry_details Retrurns registry details. (optional)
     * @param  bool|null $with_dnssec_data Returns DNSSEC data. (optional)
     * @param  bool|null $with_abuse_details Returns domain abuse details. (optional)
     * @param  bool|null $with_whois_privacy_data Returns WPP data. (optional)
     * @param  bool|null $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  bool|null $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainGetDomainResponse|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDomainWithHttpInfo(
        int $id,
        ?string $domain_name = null,
        ?string $domain_extension = null,
        ?string $domain_idn_extension = null,
        ?int $reseller_id = null,
        ?string $queue_status = null,
        ?bool $with_history = null,
        ?bool $with_api_history = null,
        ?bool $with_additional_data = null,
        ?bool $with_registry_details = null,
        ?bool $with_dnssec_data = null,
        ?bool $with_abuse_details = null,
        ?bool $with_whois_privacy_data = null,
        ?bool $with_registry_statuses = null,
        ?bool $is_deleted = null,
        string $contentType = self::contentTypes['getDomain'][0]
    ): array
    {
        $request = $this->getDomainRequest($id, $domain_name, $domain_extension, $domain_idn_extension, $reseller_id, $queue_status, $with_history, $with_api_history, $with_additional_data, $with_registry_details, $with_dnssec_data, $with_abuse_details, $with_whois_privacy_data, $with_registry_statuses, $is_deleted, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainGetDomainResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainGetDomainResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainGetDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainGetDomainResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainGetDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDomainAsync
     *
     * Get domain
     *
     * @param  int $id Domain id number (required)
     * @param  string|null $domain_name Domain name without extension. (optional)
     * @param  string|null $domain_extension Domain extension. (optional)
     * @param  string|null $domain_idn_extension Domain IDN extension. (optional)
     * @param  int|null $reseller_id Reseller id. (optional)
     * @param  string|null $queue_status The queue status. (optional)
     * @param  bool|null $with_history Returns domain mutations history. (optional)
     * @param  bool|null $with_api_history Returns domain API calls history. (optional)
     * @param  bool|null $with_additional_data Returns domain additional data. (optional)
     * @param  bool|null $with_registry_details Retrurns registry details. (optional)
     * @param  bool|null $with_dnssec_data Returns DNSSEC data. (optional)
     * @param  bool|null $with_abuse_details Returns domain abuse details. (optional)
     * @param  bool|null $with_whois_privacy_data Returns WPP data. (optional)
     * @param  bool|null $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  bool|null $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getDomainAsync(
        int $id,
        ?string $domain_name = null,
        ?string $domain_extension = null,
        ?string $domain_idn_extension = null,
        ?int $reseller_id = null,
        ?string $queue_status = null,
        ?bool $with_history = null,
        ?bool $with_api_history = null,
        ?bool $with_additional_data = null,
        ?bool $with_registry_details = null,
        ?bool $with_dnssec_data = null,
        ?bool $with_abuse_details = null,
        ?bool $with_whois_privacy_data = null,
        ?bool $with_registry_statuses = null,
        ?bool $is_deleted = null,
        string $contentType = self::contentTypes['getDomain'][0]
    ): PromiseInterface
    {
        return $this->getDomainAsyncWithHttpInfo($id, $domain_name, $domain_extension, $domain_idn_extension, $reseller_id, $queue_status, $with_history, $with_api_history, $with_additional_data, $with_registry_details, $with_dnssec_data, $with_abuse_details, $with_whois_privacy_data, $with_registry_statuses, $is_deleted, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDomainAsyncWithHttpInfo
     *
     * Get domain
     *
     * @param  int $id Domain id number (required)
     * @param  string|null $domain_name Domain name without extension. (optional)
     * @param  string|null $domain_extension Domain extension. (optional)
     * @param  string|null $domain_idn_extension Domain IDN extension. (optional)
     * @param  int|null $reseller_id Reseller id. (optional)
     * @param  string|null $queue_status The queue status. (optional)
     * @param  bool|null $with_history Returns domain mutations history. (optional)
     * @param  bool|null $with_api_history Returns domain API calls history. (optional)
     * @param  bool|null $with_additional_data Returns domain additional data. (optional)
     * @param  bool|null $with_registry_details Retrurns registry details. (optional)
     * @param  bool|null $with_dnssec_data Returns DNSSEC data. (optional)
     * @param  bool|null $with_abuse_details Returns domain abuse details. (optional)
     * @param  bool|null $with_whois_privacy_data Returns WPP data. (optional)
     * @param  bool|null $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  bool|null $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getDomainAsyncWithHttpInfo(
        $id,
        $domain_name = null,
        $domain_extension = null,
        $domain_idn_extension = null,
        $reseller_id = null,
        $queue_status = null,
        $with_history = null,
        $with_api_history = null,
        $with_additional_data = null,
        $with_registry_details = null,
        $with_dnssec_data = null,
        $with_abuse_details = null,
        $with_whois_privacy_data = null,
        $with_registry_statuses = null,
        $is_deleted = null,
        string $contentType = self::contentTypes['getDomain'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainGetDomainResponse';
        $request = $this->getDomainRequest($id, $domain_name, $domain_extension, $domain_idn_extension, $reseller_id, $queue_status, $with_history, $with_api_history, $with_additional_data, $with_registry_details, $with_dnssec_data, $with_abuse_details, $with_whois_privacy_data, $with_registry_statuses, $is_deleted, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDomain'
     *
     * @param  int $id Domain id number (required)
     * @param  string|null $domain_name Domain name without extension. (optional)
     * @param  string|null $domain_extension Domain extension. (optional)
     * @param  string|null $domain_idn_extension Domain IDN extension. (optional)
     * @param  int|null $reseller_id Reseller id. (optional)
     * @param  string|null $queue_status The queue status. (optional)
     * @param  bool|null $with_history Returns domain mutations history. (optional)
     * @param  bool|null $with_api_history Returns domain API calls history. (optional)
     * @param  bool|null $with_additional_data Returns domain additional data. (optional)
     * @param  bool|null $with_registry_details Retrurns registry details. (optional)
     * @param  bool|null $with_dnssec_data Returns DNSSEC data. (optional)
     * @param  bool|null $with_abuse_details Returns domain abuse details. (optional)
     * @param  bool|null $with_whois_privacy_data Returns WPP data. (optional)
     * @param  bool|null $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  bool|null $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDomainRequest(
        $id,
        $domain_name = null,
        $domain_extension = null,
        $domain_idn_extension = null,
        $reseller_id = null,
        $queue_status = null,
        $with_history = null,
        $with_api_history = null,
        $with_additional_data = null,
        $with_registry_details = null,
        $with_dnssec_data = null,
        $with_abuse_details = null,
        $with_whois_privacy_data = null,
        $with_registry_statuses = null,
        $is_deleted = null,
        string $contentType = self::contentTypes['getDomain'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling getDomain'
            );
        }
















        $resourcePath = '/v1beta/domains/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domain_name,
            'domain.name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domain_extension,
            'domain.extension', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domain_idn_extension,
            'domain.idn_extension', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $reseller_id,
            'reseller_id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $queue_status,
            'queue_status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_history,
            'with_history', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_api_history,
            'with_api_history', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_additional_data,
            'with_additional_data', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_registry_details,
            'with_registry_details', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_dnssec_data,
            'with_dnssec_data', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_abuse_details,
            'with_abuse_details', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_whois_privacy_data,
            'with_whois_privacy_data', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_registry_statuses,
            'with_registry_statuses', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_deleted,
            'is_deleted', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDomains
     *
     * List domains
     *
     * @param  string|null $order_by_id Domain id number. (optional)
     * @param  string|null $order_by_domain_name The domain name. (optional)
     * @param  string|null $order_by_domain_extension Domain extension. (optional)
     * @param  string|null $order_by_order_date The order date. (optional)
     * @param  string|null $order_by_active_date The active date. (optional)
     * @param  string|null $order_by_expiration_date Domain expiration date. (optional)
     * @param  string|null $order_by_renewal_date Date on which domain will be renewed. (optional)
     * @param  string|null $order_by_status Domain status. (optional)
     * @param  string|null $order_by_transfer_date The transfer date. (optional)
     * @param  int|null $limit The limit. (optional)
     * @param  int|null $offset The offset. (optional)
     * @param  int|null $id Domain id number. (optional)
     * @param  string|null $extension Domain extension. (optional)
     * @param  string|null $renewal_date Date on which domain will be renewed. (optional)
     * @param  string|null $domain_name_pattern The domain name pattern. (optional)
     * @param  string|null $ns_group_pattern Nameserver group name pattern. (optional)
     * @param  string|null $status Domain status. (optional)
     * @param  string|null $status_not_equal The status not equal. (optional)
     * @param  string|null $queue_status The queue status. (optional)
     * @param  string|null $contact_handle Handle to filter by. (optional)
     * @param  string|null $comment_pattern The comment pattern. (optional)
     * @param  bool|null $with_history With history. (optional)
     * @param  bool|null $with_api_history With api history. (optional)
     * @param  bool|null $with_document_list With document list. (optional)
     * @param  bool|null $with_additional_data With additional data. (optional)
     * @param  string|null $application_mode When new gTLD is started it gets through several phases before it becomes available for registration to everybody (General availability or GA). There are several phases before GA when it is still possible to apply for a domain, but with some restrictions. (optional)
     * @param  bool|null $with_verification_email With verification email. (optional)
     * @param  bool|null $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  string|null $response_to The to. (optional)
     * @param  bool|null $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDomains'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainListDomainsResponse|\Layer7\Openprovider\Model\ErrorError
     */
    public function listDomains(
        ?string $order_by_id = null,
        ?string $order_by_domain_name = null,
        ?string $order_by_domain_extension = null,
        ?string $order_by_order_date = null,
        ?string $order_by_active_date = null,
        ?string $order_by_expiration_date = null,
        ?string $order_by_renewal_date = null,
        ?string $order_by_status = null,
        ?string $order_by_transfer_date = null,
        ?int $limit = null,
        ?int $offset = null,
        ?int $id = null,
        ?string $extension = null,
        ?string $renewal_date = null,
        ?string $domain_name_pattern = null,
        ?string $ns_group_pattern = null,
        ?string $status = null,
        ?string $status_not_equal = null,
        ?string $queue_status = null,
        ?string $contact_handle = null,
        ?string $comment_pattern = null,
        ?bool $with_history = null,
        ?bool $with_api_history = null,
        ?bool $with_document_list = null,
        ?bool $with_additional_data = null,
        ?string $application_mode = null,
        ?bool $with_verification_email = null,
        ?bool $with_registry_statuses = null,
        ?string $response_to = null,
        ?bool $is_deleted = null,
        string $contentType = self::contentTypes['listDomains'][0]
    ): \Layer7\Openprovider\Model\DomainListDomainsResponse
    {
        list($response) = $this->listDomainsWithHttpInfo($order_by_id, $order_by_domain_name, $order_by_domain_extension, $order_by_order_date, $order_by_active_date, $order_by_expiration_date, $order_by_renewal_date, $order_by_status, $order_by_transfer_date, $limit, $offset, $id, $extension, $renewal_date, $domain_name_pattern, $ns_group_pattern, $status, $status_not_equal, $queue_status, $contact_handle, $comment_pattern, $with_history, $with_api_history, $with_document_list, $with_additional_data, $application_mode, $with_verification_email, $with_registry_statuses, $response_to, $is_deleted, $contentType);
        return $response;
    }

    /**
     * Operation listDomainsWithHttpInfo
     *
     * List domains
     *
     * @param  string|null $order_by_id Domain id number. (optional)
     * @param  string|null $order_by_domain_name The domain name. (optional)
     * @param  string|null $order_by_domain_extension Domain extension. (optional)
     * @param  string|null $order_by_order_date The order date. (optional)
     * @param  string|null $order_by_active_date The active date. (optional)
     * @param  string|null $order_by_expiration_date Domain expiration date. (optional)
     * @param  string|null $order_by_renewal_date Date on which domain will be renewed. (optional)
     * @param  string|null $order_by_status Domain status. (optional)
     * @param  string|null $order_by_transfer_date The transfer date. (optional)
     * @param  int|null $limit The limit. (optional)
     * @param  int|null $offset The offset. (optional)
     * @param  int|null $id Domain id number. (optional)
     * @param  string|null $extension Domain extension. (optional)
     * @param  string|null $renewal_date Date on which domain will be renewed. (optional)
     * @param  string|null $domain_name_pattern The domain name pattern. (optional)
     * @param  string|null $ns_group_pattern Nameserver group name pattern. (optional)
     * @param  string|null $status Domain status. (optional)
     * @param  string|null $status_not_equal The status not equal. (optional)
     * @param  string|null $queue_status The queue status. (optional)
     * @param  string|null $contact_handle Handle to filter by. (optional)
     * @param  string|null $comment_pattern The comment pattern. (optional)
     * @param  bool|null $with_history With history. (optional)
     * @param  bool|null $with_api_history With api history. (optional)
     * @param  bool|null $with_document_list With document list. (optional)
     * @param  bool|null $with_additional_data With additional data. (optional)
     * @param  string|null $application_mode When new gTLD is started it gets through several phases before it becomes available for registration to everybody (General availability or GA). There are several phases before GA when it is still possible to apply for a domain, but with some restrictions. (optional)
     * @param  bool|null $with_verification_email With verification email. (optional)
     * @param  bool|null $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  string|null $response_to The to. (optional)
     * @param  bool|null $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDomains'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainListDomainsResponse|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function listDomainsWithHttpInfo(
        ?string $order_by_id = null,
        ?string $order_by_domain_name = null,
        ?string $order_by_domain_extension = null,
        ?string $order_by_order_date = null,
        ?string $order_by_active_date = null,
        ?string $order_by_expiration_date = null,
        ?string $order_by_renewal_date = null,
        ?string $order_by_status = null,
        ?string $order_by_transfer_date = null,
        ?int $limit = null,
        ?int $offset = null,
        ?int $id = null,
        ?string $extension = null,
        ?string $renewal_date = null,
        ?string $domain_name_pattern = null,
        ?string $ns_group_pattern = null,
        ?string $status = null,
        ?string $status_not_equal = null,
        ?string $queue_status = null,
        ?string $contact_handle = null,
        ?string $comment_pattern = null,
        ?bool $with_history = null,
        ?bool $with_api_history = null,
        ?bool $with_document_list = null,
        ?bool $with_additional_data = null,
        ?string $application_mode = null,
        ?bool $with_verification_email = null,
        ?bool $with_registry_statuses = null,
        ?string $response_to = null,
        ?bool $is_deleted = null,
        string $contentType = self::contentTypes['listDomains'][0]
    ): array
    {
        $request = $this->listDomainsRequest($order_by_id, $order_by_domain_name, $order_by_domain_extension, $order_by_order_date, $order_by_active_date, $order_by_expiration_date, $order_by_renewal_date, $order_by_status, $order_by_transfer_date, $limit, $offset, $id, $extension, $renewal_date, $domain_name_pattern, $ns_group_pattern, $status, $status_not_equal, $queue_status, $contact_handle, $comment_pattern, $with_history, $with_api_history, $with_document_list, $with_additional_data, $application_mode, $with_verification_email, $with_registry_statuses, $response_to, $is_deleted, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainListDomainsResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainListDomainsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainListDomainsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainListDomainsResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainListDomainsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listDomainsAsync
     *
     * List domains
     *
     * @param  string|null $order_by_id Domain id number. (optional)
     * @param  string|null $order_by_domain_name The domain name. (optional)
     * @param  string|null $order_by_domain_extension Domain extension. (optional)
     * @param  string|null $order_by_order_date The order date. (optional)
     * @param  string|null $order_by_active_date The active date. (optional)
     * @param  string|null $order_by_expiration_date Domain expiration date. (optional)
     * @param  string|null $order_by_renewal_date Date on which domain will be renewed. (optional)
     * @param  string|null $order_by_status Domain status. (optional)
     * @param  string|null $order_by_transfer_date The transfer date. (optional)
     * @param  int|null $limit The limit. (optional)
     * @param  int|null $offset The offset. (optional)
     * @param  int|null $id Domain id number. (optional)
     * @param  string|null $extension Domain extension. (optional)
     * @param  string|null $renewal_date Date on which domain will be renewed. (optional)
     * @param  string|null $domain_name_pattern The domain name pattern. (optional)
     * @param  string|null $ns_group_pattern Nameserver group name pattern. (optional)
     * @param  string|null $status Domain status. (optional)
     * @param  string|null $status_not_equal The status not equal. (optional)
     * @param  string|null $queue_status The queue status. (optional)
     * @param  string|null $contact_handle Handle to filter by. (optional)
     * @param  string|null $comment_pattern The comment pattern. (optional)
     * @param  bool|null $with_history With history. (optional)
     * @param  bool|null $with_api_history With api history. (optional)
     * @param  bool|null $with_document_list With document list. (optional)
     * @param  bool|null $with_additional_data With additional data. (optional)
     * @param  string|null $application_mode When new gTLD is started it gets through several phases before it becomes available for registration to everybody (General availability or GA). There are several phases before GA when it is still possible to apply for a domain, but with some restrictions. (optional)
     * @param  bool|null $with_verification_email With verification email. (optional)
     * @param  bool|null $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  string|null $response_to The to. (optional)
     * @param  bool|null $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDomains'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listDomainsAsync(
        ?string $order_by_id = null,
        ?string $order_by_domain_name = null,
        ?string $order_by_domain_extension = null,
        ?string $order_by_order_date = null,
        ?string $order_by_active_date = null,
        ?string $order_by_expiration_date = null,
        ?string $order_by_renewal_date = null,
        ?string $order_by_status = null,
        ?string $order_by_transfer_date = null,
        ?int $limit = null,
        ?int $offset = null,
        ?int $id = null,
        ?string $extension = null,
        ?string $renewal_date = null,
        ?string $domain_name_pattern = null,
        ?string $ns_group_pattern = null,
        ?string $status = null,
        ?string $status_not_equal = null,
        ?string $queue_status = null,
        ?string $contact_handle = null,
        ?string $comment_pattern = null,
        ?bool $with_history = null,
        ?bool $with_api_history = null,
        ?bool $with_document_list = null,
        ?bool $with_additional_data = null,
        ?string $application_mode = null,
        ?bool $with_verification_email = null,
        ?bool $with_registry_statuses = null,
        ?string $response_to = null,
        ?bool $is_deleted = null,
        string $contentType = self::contentTypes['listDomains'][0]
    ): PromiseInterface
    {
        return $this->listDomainsAsyncWithHttpInfo($order_by_id, $order_by_domain_name, $order_by_domain_extension, $order_by_order_date, $order_by_active_date, $order_by_expiration_date, $order_by_renewal_date, $order_by_status, $order_by_transfer_date, $limit, $offset, $id, $extension, $renewal_date, $domain_name_pattern, $ns_group_pattern, $status, $status_not_equal, $queue_status, $contact_handle, $comment_pattern, $with_history, $with_api_history, $with_document_list, $with_additional_data, $application_mode, $with_verification_email, $with_registry_statuses, $response_to, $is_deleted, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDomainsAsyncWithHttpInfo
     *
     * List domains
     *
     * @param  string|null $order_by_id Domain id number. (optional)
     * @param  string|null $order_by_domain_name The domain name. (optional)
     * @param  string|null $order_by_domain_extension Domain extension. (optional)
     * @param  string|null $order_by_order_date The order date. (optional)
     * @param  string|null $order_by_active_date The active date. (optional)
     * @param  string|null $order_by_expiration_date Domain expiration date. (optional)
     * @param  string|null $order_by_renewal_date Date on which domain will be renewed. (optional)
     * @param  string|null $order_by_status Domain status. (optional)
     * @param  string|null $order_by_transfer_date The transfer date. (optional)
     * @param  int|null $limit The limit. (optional)
     * @param  int|null $offset The offset. (optional)
     * @param  int|null $id Domain id number. (optional)
     * @param  string|null $extension Domain extension. (optional)
     * @param  string|null $renewal_date Date on which domain will be renewed. (optional)
     * @param  string|null $domain_name_pattern The domain name pattern. (optional)
     * @param  string|null $ns_group_pattern Nameserver group name pattern. (optional)
     * @param  string|null $status Domain status. (optional)
     * @param  string|null $status_not_equal The status not equal. (optional)
     * @param  string|null $queue_status The queue status. (optional)
     * @param  string|null $contact_handle Handle to filter by. (optional)
     * @param  string|null $comment_pattern The comment pattern. (optional)
     * @param  bool|null $with_history With history. (optional)
     * @param  bool|null $with_api_history With api history. (optional)
     * @param  bool|null $with_document_list With document list. (optional)
     * @param  bool|null $with_additional_data With additional data. (optional)
     * @param  string|null $application_mode When new gTLD is started it gets through several phases before it becomes available for registration to everybody (General availability or GA). There are several phases before GA when it is still possible to apply for a domain, but with some restrictions. (optional)
     * @param  bool|null $with_verification_email With verification email. (optional)
     * @param  bool|null $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  string|null $response_to The to. (optional)
     * @param  bool|null $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDomains'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listDomainsAsyncWithHttpInfo(
        $order_by_id = null,
        $order_by_domain_name = null,
        $order_by_domain_extension = null,
        $order_by_order_date = null,
        $order_by_active_date = null,
        $order_by_expiration_date = null,
        $order_by_renewal_date = null,
        $order_by_status = null,
        $order_by_transfer_date = null,
        $limit = null,
        $offset = null,
        $id = null,
        $extension = null,
        $renewal_date = null,
        $domain_name_pattern = null,
        $ns_group_pattern = null,
        $status = null,
        $status_not_equal = null,
        $queue_status = null,
        $contact_handle = null,
        $comment_pattern = null,
        $with_history = null,
        $with_api_history = null,
        $with_document_list = null,
        $with_additional_data = null,
        $application_mode = null,
        $with_verification_email = null,
        $with_registry_statuses = null,
        $response_to = null,
        $is_deleted = null,
        string $contentType = self::contentTypes['listDomains'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainListDomainsResponse';
        $request = $this->listDomainsRequest($order_by_id, $order_by_domain_name, $order_by_domain_extension, $order_by_order_date, $order_by_active_date, $order_by_expiration_date, $order_by_renewal_date, $order_by_status, $order_by_transfer_date, $limit, $offset, $id, $extension, $renewal_date, $domain_name_pattern, $ns_group_pattern, $status, $status_not_equal, $queue_status, $contact_handle, $comment_pattern, $with_history, $with_api_history, $with_document_list, $with_additional_data, $application_mode, $with_verification_email, $with_registry_statuses, $response_to, $is_deleted, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDomains'
     *
     * @param  string|null $order_by_id Domain id number. (optional)
     * @param  string|null $order_by_domain_name The domain name. (optional)
     * @param  string|null $order_by_domain_extension Domain extension. (optional)
     * @param  string|null $order_by_order_date The order date. (optional)
     * @param  string|null $order_by_active_date The active date. (optional)
     * @param  string|null $order_by_expiration_date Domain expiration date. (optional)
     * @param  string|null $order_by_renewal_date Date on which domain will be renewed. (optional)
     * @param  string|null $order_by_status Domain status. (optional)
     * @param  string|null $order_by_transfer_date The transfer date. (optional)
     * @param  int|null $limit The limit. (optional)
     * @param  int|null $offset The offset. (optional)
     * @param  int|null $id Domain id number. (optional)
     * @param  string|null $extension Domain extension. (optional)
     * @param  string|null $renewal_date Date on which domain will be renewed. (optional)
     * @param  string|null $domain_name_pattern The domain name pattern. (optional)
     * @param  string|null $ns_group_pattern Nameserver group name pattern. (optional)
     * @param  string|null $status Domain status. (optional)
     * @param  string|null $status_not_equal The status not equal. (optional)
     * @param  string|null $queue_status The queue status. (optional)
     * @param  string|null $contact_handle Handle to filter by. (optional)
     * @param  string|null $comment_pattern The comment pattern. (optional)
     * @param  bool|null $with_history With history. (optional)
     * @param  bool|null $with_api_history With api history. (optional)
     * @param  bool|null $with_document_list With document list. (optional)
     * @param  bool|null $with_additional_data With additional data. (optional)
     * @param  string|null $application_mode When new gTLD is started it gets through several phases before it becomes available for registration to everybody (General availability or GA). There are several phases before GA when it is still possible to apply for a domain, but with some restrictions. (optional)
     * @param  bool|null $with_verification_email With verification email. (optional)
     * @param  bool|null $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  string|null $response_to The to. (optional)
     * @param  bool|null $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDomains'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listDomainsRequest(
        $order_by_id = null,
        $order_by_domain_name = null,
        $order_by_domain_extension = null,
        $order_by_order_date = null,
        $order_by_active_date = null,
        $order_by_expiration_date = null,
        $order_by_renewal_date = null,
        $order_by_status = null,
        $order_by_transfer_date = null,
        $limit = null,
        $offset = null,
        $id = null,
        $extension = null,
        $renewal_date = null,
        $domain_name_pattern = null,
        $ns_group_pattern = null,
        $status = null,
        $status_not_equal = null,
        $queue_status = null,
        $contact_handle = null,
        $comment_pattern = null,
        $with_history = null,
        $with_api_history = null,
        $with_document_list = null,
        $with_additional_data = null,
        $application_mode = null,
        $with_verification_email = null,
        $with_registry_statuses = null,
        $response_to = null,
        $is_deleted = null,
        string $contentType = self::contentTypes['listDomains'][0]
    ): Request
    {
































        $resourcePath = '/v1beta/domains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_id,
            'order_by.id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_domain_name,
            'order_by.domain_name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_domain_extension,
            'order_by.domain_extension', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_order_date,
            'order_by.order_date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_active_date,
            'order_by.active_date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_expiration_date,
            'order_by.expiration_date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_renewal_date,
            'order_by.renewal_date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_status,
            'order_by.status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_transfer_date,
            'order_by.transfer_date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $extension,
            'extension', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $renewal_date,
            'renewal_date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domain_name_pattern,
            'domain_name_pattern', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ns_group_pattern,
            'ns_group_pattern', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status_not_equal,
            'status_not_equal', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $queue_status,
            'queue_status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_handle,
            'contact_handle', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment_pattern,
            'comment_pattern', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_history,
            'with_history', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_api_history,
            'with_api_history', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_document_list,
            'with_document_list', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_additional_data,
            'with_additional_data', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $application_mode,
            'application_mode', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_verification_email,
            'with_verification_email', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_registry_statuses,
            'with_registry_statuses', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_to,
            'response.to', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_deleted,
            'is_deleted', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renewDomain
     *
     * Renew domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainRenewDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renewDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainRenewDomainResponse|\Layer7\Openprovider\Model\ErrorError
     */
    public function renewDomain(
        int $id,
        \Layer7\Openprovider\Model\DomainRenewDomainRequest $body,
        string $contentType = self::contentTypes['renewDomain'][0]
    ): \Layer7\Openprovider\Model\DomainRenewDomainResponse
    {
        list($response) = $this->renewDomainWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation renewDomainWithHttpInfo
     *
     * Renew domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainRenewDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renewDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainRenewDomainResponse|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function renewDomainWithHttpInfo(
        int $id,
        \Layer7\Openprovider\Model\DomainRenewDomainRequest $body,
        string $contentType = self::contentTypes['renewDomain'][0]
    ): array
    {
        $request = $this->renewDomainRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainRenewDomainResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainRenewDomainResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainRenewDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainRenewDomainResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainRenewDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation renewDomainAsync
     *
     * Renew domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainRenewDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renewDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function renewDomainAsync(
        int $id,
        \Layer7\Openprovider\Model\DomainRenewDomainRequest $body,
        string $contentType = self::contentTypes['renewDomain'][0]
    ): PromiseInterface
    {
        return $this->renewDomainAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renewDomainAsyncWithHttpInfo
     *
     * Renew domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainRenewDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renewDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function renewDomainAsyncWithHttpInfo(
        $id,
        $body,
        string $contentType = self::contentTypes['renewDomain'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainRenewDomainResponse';
        $request = $this->renewDomainRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renewDomain'
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainRenewDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renewDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function renewDomainRequest(
        $id,
        $body,
        string $contentType = self::contentTypes['renewDomain'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling renewDomain'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling renewDomain'
            );
        }


        $resourcePath = '/v1beta/domains/{id}/renew';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restoreDomain
     *
     * Restore domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainRestoreDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainRestoreDomainResponse|\Layer7\Openprovider\Model\ErrorError
     */
    public function restoreDomain(
        int $id,
        \Layer7\Openprovider\Model\DomainRestoreDomainRequest $body,
        string $contentType = self::contentTypes['restoreDomain'][0]
    ): \Layer7\Openprovider\Model\DomainRestoreDomainResponse
    {
        list($response) = $this->restoreDomainWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation restoreDomainWithHttpInfo
     *
     * Restore domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainRestoreDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainRestoreDomainResponse|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function restoreDomainWithHttpInfo(
        int $id,
        \Layer7\Openprovider\Model\DomainRestoreDomainRequest $body,
        string $contentType = self::contentTypes['restoreDomain'][0]
    ): array
    {
        $request = $this->restoreDomainRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainRestoreDomainResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainRestoreDomainResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainRestoreDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainRestoreDomainResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainRestoreDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restoreDomainAsync
     *
     * Restore domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainRestoreDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restoreDomainAsync(
        int $id,
        \Layer7\Openprovider\Model\DomainRestoreDomainRequest $body,
        string $contentType = self::contentTypes['restoreDomain'][0]
    ): PromiseInterface
    {
        return $this->restoreDomainAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restoreDomainAsyncWithHttpInfo
     *
     * Restore domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainRestoreDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restoreDomainAsyncWithHttpInfo(
        $id,
        $body,
        string $contentType = self::contentTypes['restoreDomain'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainRestoreDomainResponse';
        $request = $this->restoreDomainRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restoreDomain'
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainRestoreDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restoreDomainRequest(
        $id,
        $body,
        string $contentType = self::contentTypes['restoreDomain'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restoreDomain'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling restoreDomain'
            );
        }


        $resourcePath = '/v1beta/domains/{id}/restore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendFoa1
     *
     * Send foa1
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainSendFoa1Request $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendFoa1'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainSendFoa1Response|\Layer7\Openprovider\Model\ErrorError
     */
    public function sendFoa1(
        int $id,
        \Layer7\Openprovider\Model\DomainSendFoa1Request $body,
        string $contentType = self::contentTypes['sendFoa1'][0]
    ): \Layer7\Openprovider\Model\DomainSendFoa1Response
    {
        list($response) = $this->sendFoa1WithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation sendFoa1WithHttpInfo
     *
     * Send foa1
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainSendFoa1Request $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendFoa1'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainSendFoa1Response|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendFoa1WithHttpInfo(
        int $id,
        \Layer7\Openprovider\Model\DomainSendFoa1Request $body,
        string $contentType = self::contentTypes['sendFoa1'][0]
    ): array
    {
        $request = $this->sendFoa1Request($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainSendFoa1Response', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainSendFoa1Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainSendFoa1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainSendFoa1Response';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainSendFoa1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendFoa1Async
     *
     * Send foa1
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainSendFoa1Request $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendFoa1'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function sendFoa1Async(
        int $id,
        \Layer7\Openprovider\Model\DomainSendFoa1Request $body,
        string $contentType = self::contentTypes['sendFoa1'][0]
    ): PromiseInterface
    {
        return $this->sendFoa1AsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendFoa1AsyncWithHttpInfo
     *
     * Send foa1
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainSendFoa1Request $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendFoa1'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function sendFoa1AsyncWithHttpInfo(
        $id,
        $body,
        string $contentType = self::contentTypes['sendFoa1'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainSendFoa1Response';
        $request = $this->sendFoa1Request($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendFoa1'
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainSendFoa1Request $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendFoa1'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendFoa1Request(
        $id,
        $body,
        string $contentType = self::contentTypes['sendFoa1'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling sendFoa1'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling sendFoa1'
            );
        }


        $resourcePath = '/v1beta/domains/{id}/transfer/send-foa1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tradeDomain
     *
     * Trade domain
     *
     * @param  \Layer7\Openprovider\Model\DomainTradeDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tradeDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainTradeDomainResponse|\Layer7\Openprovider\Model\ErrorError
     */
    public function tradeDomain(
        \Layer7\Openprovider\Model\DomainTradeDomainRequest $body,
        string $contentType = self::contentTypes['tradeDomain'][0]
    ): \Layer7\Openprovider\Model\DomainTradeDomainResponse
    {
        list($response) = $this->tradeDomainWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation tradeDomainWithHttpInfo
     *
     * Trade domain
     *
     * @param  \Layer7\Openprovider\Model\DomainTradeDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tradeDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainTradeDomainResponse|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function tradeDomainWithHttpInfo(
        \Layer7\Openprovider\Model\DomainTradeDomainRequest $body,
        string $contentType = self::contentTypes['tradeDomain'][0]
    ): array
    {
        $request = $this->tradeDomainRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainTradeDomainResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainTradeDomainResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainTradeDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainTradeDomainResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainTradeDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tradeDomainAsync
     *
     * Trade domain
     *
     * @param  \Layer7\Openprovider\Model\DomainTradeDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tradeDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function tradeDomainAsync(
        \Layer7\Openprovider\Model\DomainTradeDomainRequest $body,
        string $contentType = self::contentTypes['tradeDomain'][0]
    ): PromiseInterface
    {
        return $this->tradeDomainAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tradeDomainAsyncWithHttpInfo
     *
     * Trade domain
     *
     * @param  \Layer7\Openprovider\Model\DomainTradeDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tradeDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function tradeDomainAsyncWithHttpInfo(
        $body,
        string $contentType = self::contentTypes['tradeDomain'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainTradeDomainResponse';
        $request = $this->tradeDomainRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tradeDomain'
     *
     * @param  \Layer7\Openprovider\Model\DomainTradeDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tradeDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function tradeDomainRequest(
        $body,
        string $contentType = self::contentTypes['tradeDomain'][0]
    ): Request
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling tradeDomain'
            );
        }


        $resourcePath = '/v1beta/domains/trade';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transferDomain
     *
     * Transfer domain
     *
     * @param  \Layer7\Openprovider\Model\DomainTransferDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainTransferDomainResponse|\Layer7\Openprovider\Model\ErrorError
     */
    public function transferDomain(
        \Layer7\Openprovider\Model\DomainTransferDomainRequest $body,
        string $contentType = self::contentTypes['transferDomain'][0]
    ): \Layer7\Openprovider\Model\DomainTransferDomainResponse
    {
        list($response) = $this->transferDomainWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation transferDomainWithHttpInfo
     *
     * Transfer domain
     *
     * @param  \Layer7\Openprovider\Model\DomainTransferDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainTransferDomainResponse|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function transferDomainWithHttpInfo(
        \Layer7\Openprovider\Model\DomainTransferDomainRequest $body,
        string $contentType = self::contentTypes['transferDomain'][0]
    ): array
    {
        $request = $this->transferDomainRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainTransferDomainResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainTransferDomainResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainTransferDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainTransferDomainResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainTransferDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transferDomainAsync
     *
     * Transfer domain
     *
     * @param  \Layer7\Openprovider\Model\DomainTransferDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function transferDomainAsync(
        \Layer7\Openprovider\Model\DomainTransferDomainRequest $body,
        string $contentType = self::contentTypes['transferDomain'][0]
    ): PromiseInterface
    {
        return $this->transferDomainAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transferDomainAsyncWithHttpInfo
     *
     * Transfer domain
     *
     * @param  \Layer7\Openprovider\Model\DomainTransferDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function transferDomainAsyncWithHttpInfo(
        $body,
        string $contentType = self::contentTypes['transferDomain'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainTransferDomainResponse';
        $request = $this->transferDomainRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transferDomain'
     *
     * @param  \Layer7\Openprovider\Model\DomainTransferDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transferDomainRequest(
        $body,
        string $contentType = self::contentTypes['transferDomain'][0]
    ): Request
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling transferDomain'
            );
        }


        $resourcePath = '/v1beta/domains/transfer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tryAgainLastOperation
     *
     * Try again last operation
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainTryAgainLastOperationRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tryAgainLastOperation'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainTryAgainLastOperationResponse|\Layer7\Openprovider\Model\ErrorError
     */
    public function tryAgainLastOperation(
        int $id,
        \Layer7\Openprovider\Model\DomainTryAgainLastOperationRequest $body,
        string $contentType = self::contentTypes['tryAgainLastOperation'][0]
    ): \Layer7\Openprovider\Model\DomainTryAgainLastOperationResponse
    {
        list($response) = $this->tryAgainLastOperationWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation tryAgainLastOperationWithHttpInfo
     *
     * Try again last operation
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainTryAgainLastOperationRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tryAgainLastOperation'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainTryAgainLastOperationResponse|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function tryAgainLastOperationWithHttpInfo(
        int $id,
        \Layer7\Openprovider\Model\DomainTryAgainLastOperationRequest $body,
        string $contentType = self::contentTypes['tryAgainLastOperation'][0]
    ): array
    {
        $request = $this->tryAgainLastOperationRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainTryAgainLastOperationResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainTryAgainLastOperationResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainTryAgainLastOperationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainTryAgainLastOperationResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainTryAgainLastOperationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tryAgainLastOperationAsync
     *
     * Try again last operation
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainTryAgainLastOperationRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tryAgainLastOperation'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function tryAgainLastOperationAsync(
        int $id,
        \Layer7\Openprovider\Model\DomainTryAgainLastOperationRequest $body,
        string $contentType = self::contentTypes['tryAgainLastOperation'][0]
    ): PromiseInterface
    {
        return $this->tryAgainLastOperationAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tryAgainLastOperationAsyncWithHttpInfo
     *
     * Try again last operation
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainTryAgainLastOperationRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tryAgainLastOperation'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function tryAgainLastOperationAsyncWithHttpInfo(
        $id,
        $body,
        string $contentType = self::contentTypes['tryAgainLastOperation'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainTryAgainLastOperationResponse';
        $request = $this->tryAgainLastOperationRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tryAgainLastOperation'
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainTryAgainLastOperationRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tryAgainLastOperation'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function tryAgainLastOperationRequest(
        $id,
        $body,
        string $contentType = self::contentTypes['tryAgainLastOperation'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling tryAgainLastOperation'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling tryAgainLastOperation'
            );
        }


        $resourcePath = '/v1beta/domains/{id}/last-operation/restart';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDomain
     *
     * Update domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainUpdateDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Layer7\Openprovider\Model\DomainUpdateDomainResponse|\Layer7\Openprovider\Model\ErrorError
     */
    public function updateDomain(
        int $id,
        \Layer7\Openprovider\Model\DomainUpdateDomainRequest $body,
        string $contentType = self::contentTypes['updateDomain'][0]
    ): \Layer7\Openprovider\Model\DomainUpdateDomainResponse
    {
        list($response) = $this->updateDomainWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation updateDomainWithHttpInfo
     *
     * Update domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainUpdateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDomain'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Layer7\Openprovider\Model\DomainUpdateDomainResponse|\Layer7\Openprovider\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDomainWithHttpInfo(
        int $id,
        \Layer7\Openprovider\Model\DomainUpdateDomainRequest $body,
        string $contentType = self::contentTypes['updateDomain'][0]
    ): array
    {
        $request = $this->updateDomainRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Layer7\Openprovider\Model\DomainUpdateDomainResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\DomainUpdateDomainResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\DomainUpdateDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if (in_array('\Layer7\Openprovider\Model\ErrorError', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Layer7\Openprovider\Model\ErrorError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Layer7\Openprovider\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Layer7\Openprovider\Model\DomainUpdateDomainResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\DomainUpdateDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Layer7\Openprovider\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDomainAsync
     *
     * Update domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainUpdateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateDomainAsync(
        int $id,
        \Layer7\Openprovider\Model\DomainUpdateDomainRequest $body,
        string $contentType = self::contentTypes['updateDomain'][0]
    ): PromiseInterface
    {
        return $this->updateDomainAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDomainAsyncWithHttpInfo
     *
     * Update domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainUpdateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateDomainAsyncWithHttpInfo(
        $id,
        $body,
        string $contentType = self::contentTypes['updateDomain'][0]
    ): PromiseInterface
    {
        $returnType = '\Layer7\Openprovider\Model\DomainUpdateDomainResponse';
        $request = $this->updateDomainRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDomain'
     *
     * @param  int $id Domain id number (required)
     * @param  \Layer7\Openprovider\Model\DomainUpdateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDomain'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDomainRequest(
        $id,
        $body,
        string $contentType = self::contentTypes['updateDomain'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling updateDomain'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateDomain'
            );
        }


        $resourcePath = '/v1beta/domains/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
